from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import List
import logging

from slowapi import Limiter
from slowapi.util import get_remote_address

from database import get_db
from models import User, BroadbandPlan, BillingHistory
from schemas import Token, CustomerLogin, CustomerDashboardResponse, PaymentRequest
from auth import create_access_token, ACCESS_TOKEN_EXPIRE_MINUTES
from auth_helpers import get_current_customer

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/customer", tags=["Customer"])

# Rate limiter
limiter = Limiter(key_func=get_remote_address)


@router.post("/login", response_model=Token)
@limiter.limit("5/minute")
async def customer_login(
    request: Request,
    credentials: CustomerLogin, 
    db: Session = Depends(get_db)
):
    """Customer login with mobile number and password (rate limited)"""
    
    logger.info(f"üîê Customer login attempt: {credentials.mobile}")
    
    # Find user by mobile
    user = db.query(User).filter(User.phone == credentials.mobile).first()
    
    if not user:
        logger.warning(f"‚ùå Login failed: Mobile not found {credentials.mobile}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Mobile number not found. Please check your number.",
        )
    
    # Check if account is suspended
    if user.status == "Suspended":
        logger.warning(f"‚ùå Login failed: Account suspended {credentials.mobile}")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Your account has been suspended. Please contact support.",
        )
    
    # Verify password (plain text comparison)
    if user.user_password != credentials.password:
        logger.warning(f"‚ùå Login failed: Wrong password for {credentials.mobile}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect password. Please try again.",
        )
    
    # Create access token with expiration
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.id, "role": "customer"},
        expires_delta=access_token_expires
    )
    
    logger.info(f"‚úÖ Customer login successful: {user.name} ({user.phone})")
    
    return {"access_token": access_token, "token_type": "bearer"}


@router.get("/me")
async def get_customer_profile(
    current_user: User = Depends(get_current_customer),
    db: Session = Depends(get_db)
):
    """Get current customer's profile and plan details"""
    
    # Get plan details
    plan = db.query(BroadbandPlan).filter(
        BroadbandPlan.id == current_user.broadband_plan_id
    ).first()
    
    return {
        "id": current_user.id,
        "cs_id": current_user.cs_id,  # Added for frontend validation
        "name": current_user.name,
        "email": current_user.email,
        "mobile": current_user.phone,
        "address": current_user.address,
        "photo": current_user.photo,
        "plan_name": plan.name if plan else None,
        "plan_price": plan.price if plan else None,
        "plan_speed": plan.speed if plan else None,
        "plan_data_limit": plan.data_limit if plan else None,
        "plan_id": current_user.broadband_plan_id,  # Added plan_id for reference
        "plan_expiry_date": current_user.plan_expiry_date,
        "is_plan_active": current_user.is_plan_active,
        "payment_status": current_user.payment_status,
        "old_pending_amount": current_user.old_pending_amount,
        "payment_due_date": current_user.payment_due_date,
        "status": current_user.status
    }


@router.get("/bills")
async def get_customer_bills(
    current_user: User = Depends(get_current_customer),
    db: Session = Depends(get_db)
):
    """Get customer's billing history, invoices, and current bill"""
    from models import Invoice

    # Get plan details
    plan = db.query(BroadbandPlan).filter(
        BroadbandPlan.id == current_user.broadband_plan_id
    ).first()

    # Get billing history
    billing_history = db.query(BillingHistory).filter(
        BillingHistory.user_id == current_user.id
    ).order_by(BillingHistory.created_at.desc()).all()

    # Get invoices generated by admin
    invoices = db.query(Invoice).filter(
        Invoice.user_id == current_user.id
    ).order_by(Invoice.created_at.desc()).all()

    # Calculate current bill
    current_bill_amount = 0
    if plan:
        current_bill_amount = plan.price + current_user.old_pending_amount

    # Prepare bills list
    bills = []

    # Add current month bill if payment is pending
    if current_user.payment_status == "Pending":
        bills.append({
            "id": 0,  # Current bill
            "month": datetime.now().strftime("%B %Y"),
            "amount": current_bill_amount,
            "payment_status": "Pending",
            "due_date": current_user.payment_due_date,
            "payment_method": None,
            "paid_date": None,
            "invoice_number": None,
            "is_invoice": False
        })

    # Add invoices generated by admin (with full details)
    for invoice in invoices:
        bills.append({
            "id": invoice.id,
            "invoice_number": invoice.invoice_number,
            "month": invoice.billing_period,
            "amount": invoice.total_amount,  # Total with GST
            "payment_status": invoice.payment_status,
            "due_date": invoice.due_date,
            "payment_method": invoice.payment_method,
            "paid_date": invoice.payment_date,
            "is_invoice": True,
            "pdf_available": bool(invoice.pdf_filepath),
            "subtotal": invoice.subtotal,
            "gst_amount": invoice.gst_amount,
            "old_pending": invoice.old_pending_amount
        })

    # Add historical bills from billing history (legacy format)
    for record in billing_history:
        if record.change_type == "payment_verification":
            bills.append({
                "id": record.id,
                "month": record.created_at.strftime("%B %Y"),
                "amount": record.previous_old_pending_amount + (
                    plan.price if plan else 0
                ),
                "payment_status": record.new_payment_status,
                "due_date": record.previous_payment_due_date,
                "payment_method": record.new_payment_status,
                "paid_date": record.created_at.strftime("%Y-%m-%d"),
                "invoice_number": None,
                "is_invoice": False
            })

    # Calculate total due (only unpaid bills/invoices)
    total_due = sum(bill["amount"] for bill in bills if bill["payment_status"] == "Pending")

    return {
        "bills": bills,
        "total_due": total_due,
        "current_plan": plan.name if plan else None,
        "current_plan_price": plan.price if plan else None
    }


@router.post("/pay-bill")
@limiter.limit("10/hour")
async def pay_bill(
    request: Request,
    payment: PaymentRequest,
    current_user: User = Depends(get_current_customer),
    db: Session = Depends(get_db)
):
    """Process bill payment (rate limited to prevent abuse)"""
    
    # Get plan details
    plan = db.query(BroadbandPlan).filter(
        BroadbandPlan.id == current_user.broadband_plan_id
    ).first()
    
    if not plan:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No active plan found"
        )
    
    expected_amount = plan.price + current_user.old_pending_amount
    
    # Log payment attempt
    logger.info(
        f"üí≥ Payment attempt: {current_user.name} - "
        f"Method: {payment.payment_method}, "
        f"Expected: ‚Çπ{expected_amount}"
    )
    
    # Determine payment status based on method
    if payment.payment_method.lower() == 'upi':
        new_payment_status = "VerifiedByUpi"
    elif payment.payment_method.lower() == 'card':
        new_payment_status = "VerifiedByUpi"  # Treat card as UPI
    elif payment.payment_method.lower() == 'netbanking':
        new_payment_status = "VerifiedByUpi"  # Treat netbanking as UPI
    else:
        new_payment_status = "VerifiedByCash"

    # Check if this payment is for an invoice (bill_id > 0 indicates invoice)
    from models import Invoice
    invoice = None
    if payment.bill_id and payment.bill_id > 0:
        invoice = db.query(Invoice).filter(
            Invoice.id == payment.bill_id,
            Invoice.user_id == current_user.id  # Security: Ensure invoice belongs to user
        ).first()

        if invoice:
            # Update invoice with payment details
            invoice.payment_status = new_payment_status
            invoice.payment_method = payment.payment_method
            invoice.payment_date = datetime.now().strftime("%Y-%m-%d")
            invoice.transaction_id = payment.transaction_id or f"TXN-{datetime.now().strftime('%Y%m%d%H%M%S')}"
            logger.info(f"üí∞ Invoice {invoice.invoice_number} marked as paid via {payment.payment_method}")

    # Update user payment status
    current_user.payment_status = new_payment_status

    # Save old values for billing history
    old_payment_status = "Pending"
    old_pending = current_user.old_pending_amount
    old_due_date = current_user.payment_due_date

    # Update user
    current_user.payment_due_date = "Paid"
    current_user.old_pending_amount = 0

    # Create billing history entry
    billing_record = BillingHistory(
        user_id=current_user.id,
        admin_email="customer_self_payment",
        previous_payment_status=old_payment_status,
        new_payment_status=new_payment_status,
        previous_old_pending_amount=old_pending,
        new_old_pending_amount=0,
        previous_payment_due_date=old_due_date,
        new_payment_due_date="Paid",
        previous_plan_id=plan.id,
        previous_plan_name=plan.name,
        new_plan_id=plan.id,
        new_plan_name=plan.name,
        change_type="payment_verification",
        notes=f"Customer self-payment via {payment.payment_method}. Transaction: {payment.transaction_id or 'N/A'}"
        + (f" | Invoice: {invoice.invoice_number}" if invoice else "")
    )

    db.add(billing_record)
    db.commit()
    
    logger.info(f"‚úÖ Payment received from {current_user.name} via {payment.payment_method}")
    
    # Generate transaction ID if not provided
    txn_id = payment.transaction_id or f"TXN-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        "success": True,
        "message": "Payment successful! Your connection is secure.",
        "transaction_id": txn_id,
        "amount_paid": expected_amount,
        "payment_method": payment.payment_method,
        "payment_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }


@router.get("/download-invoice/{bill_id}")
async def download_invoice(
    bill_id: int,
    current_user: User = Depends(get_current_customer),
    db: Session = Depends(get_db)
):
    """Download invoice PDF file"""
    from models import Invoice
    from fastapi.responses import FileResponse
    from pathlib import Path

    # Find invoice by ID
    invoice = db.query(Invoice).filter(Invoice.id == bill_id).first()

    if not invoice:
        logger.warning(f"‚ùå Invoice #{bill_id} not found")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Invoice not found"
        )

    # Security check: Ensure invoice belongs to current user
    if invoice.user_id != current_user.id:
        logger.warning(f"‚ùå User {current_user.cs_id} attempted to access invoice for user {invoice.user_id}")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You do not have permission to access this invoice"
        )

    # Check if PDF file exists
    pdf_path = Path(invoice.pdf_filepath)
    if not pdf_path.exists():
        logger.error(f"‚ùå PDF file not found: {pdf_path}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Invoice PDF file not found. Please contact support."
        )

    logger.info(f"üìÑ Serving invoice {invoice.invoice_number} to {current_user.name} ({current_user.cs_id})")

    # Return PDF file
    return FileResponse(
        str(pdf_path),
        media_type="application/pdf",
        filename=f"invoice_{current_user.cs_id}_{invoice.invoice_number}.pdf"
    )